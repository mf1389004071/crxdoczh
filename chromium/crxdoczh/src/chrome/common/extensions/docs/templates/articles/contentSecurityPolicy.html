<h1><!--@Content Security Policy (CSP)-->内容安全策略（CSP）</h1>


<p>
  <!--@In order to mitigate a large class of potential cross-site scripting issues,
  Chrome's extension system has incorporated the general concept of
  <a href="http://dvcs.w3.org/hg/content-security-policy/raw-file/tip/csp-specification.dev.html">
    <strong>Content Security Policy (CSP)</strong>
  </a>. This introduces some fairly strict policies that will make extensions
  more secure by default, and provides you with the ability to create and
  enforce rules governing the types of content that can be loaded and executed
  by your extensions and applications.-->
  为了缓解很大一部分潜在的跨站脚本问题，Chrome
  浏览器的扩展程序系统引入了<a
  href="http://dvcs.w3.org/hg/content-security-policy/raw-file/tip/csp-specification.dev.html"
  ><strong>内容安全策略（CSP）</strong></a>的一般概念。这将引入一些相当严格的策略，会使扩展程序在默认情况下更加安全，并使您能够创建并强制应用一些规则，管理您的扩展程序和应用允许加载的内容类型。
</p>

<p>
  <!--@In general, CSP works as a black/whitelisting mechanism for resources loaded
  or executed by your extensions. Defining a reasonable policy for your
  extension enables you to carefully consider the resources that your extension
  requires, and to ask the browser to ensure that those are the only resources
  your extension has access to. These policies provide security over and above
  the <a href="declare_permissions">host permissions</a> your extension
  requests; they're an additional layer of protection, not a replacement.-->
  大体上，CSP 以白名单/黑名单的机制对您的扩展程序加载或执行的资源起作用。为您的扩展程序定义一项合理的策略使您可以仔细考虑您的扩展程序需要的资源，并且使浏览器确保您的扩展程序只能访问指定的那些资源。这些策略提供了比您的扩展程序请求的<a href="declare_permissions">主机权限</a>更高的安全性，它们是额外的保护层，而不是替代品。
</p>

<p>
  <!--@On the web, such a policy is defined via an HTTP header or <code>meta</code>
  element. Inside Chrome's extension system, neither is an appropriate
  mechanism. Instead, an extension's policy is defined via the extension's
  <a href="manifest"><code>manifest.json</code></a> file as follows:-->
  在网页中，这样的策略通过 HTTP 头信息或者
  <code>meta</code> 元素定义。在 Chrome
  浏览器的扩展程序系统中，这些都不是合适的方式。扩展程序的策略通过扩展程序的
  <a href="manifest"><code>manifest.json</code></a>
  文件定义，如下所示：
</p>

<pre data-filename="manifest.json">
{
  ...,
  "content_security_policy": "[策略字符串写在这里]"
  ...
}
</pre>

<p class="note">
  <!--@For full details regarding CSP's syntax, please take a look at
  <a href="http://dvcs.w3.org/hg/content-security-policy/raw-file/tip/csp-specification.dev.html#syntax">
    the Content Security Policy specification
  </a>, and the <a href="http://www.html5rocks.com/en/tutorials/security/content-security-policy/">
    "An Introduction to Content Security Policy"
  </a> article on HTML5Rocks.-->
  有关 CSP 语法的完整细节，请参见<a href="http://dvcs.w3.org/hg/content-security-policy/raw-file/tip/csp-specification.dev.html#syntax">内容安全策略规范</a>（英文），您还可参考
  HTML5Rocks
  上的<a href="http://www.html5rocks.com/en/tutorials/security/content-security-policy/">内容安全策略简介</a>（英文）这篇文章。
</p>

<h2 id="restrictions"><!--@Default Policy Restrictions-->默认策略限制</h2>

<p>
  <!--@Packages that do not define a <a href="manifestVersion">
    <code>manifest_version</code>
  </a> have no default content security policy. Those that select
  <code>manifest_version</code> 2, have a default content security policy
  of:-->
  没有定义
  <a href="manifestVersion"><code>manifest_version</code></a>（清单文件版本） 的扩展程序包没有默认的内容安全策略，而选择
  <code>manifest_version</code> 2
  的扩展程序具有如下默认的内容安全策略：
</p>

<pre>script-src 'self'; object-src 'self'</pre>

<p>
  <!--@This policy adds security by limiting extensions and applications in three 
  ways:-->
  这一策略通过三种方式限制扩展程序和应用，来增强安全性：
</p>

<h3 id="JSEval"><!--@Eval and related functions are disabled-->eval 及相关函数已禁用</h3>

<p><!--@Code like the following does not work:-->如下所示的代码不能工作：</p>

<pre>
alert(eval("foo.bar.baz"));
window.setTimeout("alert('hi')", 10);
window.setInterval("alert('hi')", 10);
new Function("return foo.bar.baz");
</pre>

<p><!--@Evaluating strings of JavaScript like this is a common XSS attack vector.
Instead, you should write code like:-->
像这样对 JavaScript 字符串求值是一种常见的 XSS
攻击载体，而您应该编写如下所示的代码：

<pre>
alert(foo &amp;&amp; foo.bar &amp;&amp; foo.bar.baz);
window.setTimeout(function() { alert('hi'); }, 10);
window.setInterval(function() { alert('hi'); }, 10);
function() { return foo &amp;&amp; foo.bar &amp;&amp; foo.bar.baz };
</pre>

<h3 id="JSExecution"><!--@Inline JavaScript will not be executed-->内嵌 JavaScript 代码将不会执行</h3>

<p>
  <!--@Inline JavaScript will not be executed. This restriction bans both inline
 <code>&lt;script&gt;</code> blocks <strong>and</strong> inline event handlers
 (e.g. <code>&lt;button onclick="..."&gt;</code>).-->
 内嵌 JavaScript 代码将不会执行。这一限制<strong>既禁用了</strong>内嵌的
 <code>&lt;script&gt;</code>块，<strong>同时也包括</strong>内嵌的事件处理函数（例如<code>&lt;button onclick="..."&gt;</code>）。
</p>

<p>
  <!--@The first restriction wipes out a huge class of cross-site scripting attacks
  by making it impossible for you to accidentally execute script provided by a
  malicious third-party. It does, however, require you to write your code with a
  clean separation between content and behavior (which you should of course do
  anyway, right?). An example might make this clearer. You might try to write a
  <a href="browserAction#popups">Browser Action's popup</a> as a single
  <code>popup.html</code> containing:-->
  第一个限制使您不可能意外地执行任何恶意的第三方提供的脚本，彻底消除了一大部分的跨站脚本攻击。然而，这也确实要求您在编写代码时清晰地将内容与行为分开（这也是您当然应该做的吧？）。举一个例子可能会更加清楚，您可能想要编写一个包含如下内容的
  <code>popup.html</code>，作为<a href="browserAction#popups">浏览器按钮的弹出内容</a>：
</p>

<pre data-filename="popup.html">
&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;我做的很棒的弹出内容！&lt;/title&gt;
    &lt;script&gt;
      function awesome() {
        // 做些很棒的事情！
      }

      function totallyAwesome() {
        // 做些棒极了的事情！
      }

      function clickHandler(element) {
        setTimeout(<strong>"awesome(); totallyAwesome()"</strong>, 1000);
      }

      function main() {
        // 在这里进行初始化工作。
      }
    &lt;/script&gt;
  &lt;/head&gt;
  &lt;body onload="main();"&gt;
    &lt;button <strong>onclick="clickHandler(this)"</strong>&gt;
      单击看看会发生什么！
    &lt;/button&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>

<p>
  <!--@Three things will need to change in order to make this work the way you expect
  it to:-->
  有三个地方需要修改，才能使以上代码按照您预期的方式工作：
</p>

<ul>
  <li>
    <!--@The <code>clickHandler</code> definition needs to move into an external
    JavaScript file (<code>popup.js</code> would be a good target).-->
    <code>clickHandler</code> 的定义需要移至外部的
    JavaScript 文件中（例如 <code>popup.js</code> 就不错）。
  </li>
  <li>
    <p><!--@The inline event handler definitions must be rewritten in terms of
    <code>addEventListener</code> and extracted into <code>popup.js</code>.-->
    内嵌的事件处理器定义必须通过
    <code>addEventListener</code>
    重写并放在 <code>popup.js</code> 中。
    </p>
    <p><!--@If you're currently kicking off your program's execution via code like
    <code>&lt;body onload="main();"&gt;</code>, consider replacing it by hooking
    into the document's <code>DOMContentLoaded</code> event, or the window's
    <code>load</code> event, depending on your needs. Below we'll use the
    former, as it generally triggers more quickly.-->
    如果您目前仍然通过类似于
    <code>&lt;body onload="main();"&gt;</code>
    的代码开始执行您的程序，请考虑通过监听文档的
    <code>DOMContentLoaded</code> 事件或 window 的
    <code>load</code>
    事件来替换它，选择哪一种取决于您的需要。下面我们将使用前一种形式，因为通常它能够更快触发。
    </p>
  </li>
  <li>
    <!--@The <code>setTimeout</code> call will need to be rewritten to avoid
    converting the string <code>"awesome(); totallyAwesome()"</code> into
    JavaScript for execution.-->
    <code>setTimeout</code> 调用需要重写，避免将字符串
    <code>"awesome(); totallyAwesome()"</code>
    转换为 JavaScript 来执行。
  </li>
</ul>

<p>
  <!--@Those changes might look something like the following:-->
  做出这些更改后代码如下所示：
</p>

<pre data-filename="popup.js">
function awesome() {
  // 做些很棒的事情！
}

function totallyAwesome() {
  // 做些棒极了的事情！
}

<strong>function awesomeTask() {
  awesome();
  totallyAwesome();
}</strong>

function clickHandler(e) {
  setTimeout(<strong>awesomeTask</strong>, 1000);
}

function main() {
  // 在这里进行初始化工作。
}

// 通过监听文档的 `DOMContentLoaded` 事件在 DOM 完全加载后添加
// 事件监听器，当事件触发时向指定元素添加您自己的监听器。
<strong>document.addEventListener('DOMContentLoaded', function () {</strong>
  document.querySelector('button').addEventListener('click', clickHandler);
  main();
});
</pre>
<pre data-filename="popup.html">
&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;我做的很棒的弹出内容！&lt;/title&gt;
    &lt;script <strong>src="popup.js"</strong>&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;button&gt;单击看看会发生什么！&lt;/button&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>

<p>


<h3 id="resourceLoading"><!--@Only local script and and object resources are loaded-->只有本地脚本和对象资源才会加载</h3>

<p>
  <!--@Script and object resources can only be loaded from the extension's
  package, not from the web at large. This ensures that your extension only
  executes the code you've specifically approved, preventing an active network
  attacker from maliciously redirecting your request for a resource.-->
  脚本与对象资源只能从扩展程序包中加载，而不能从范围更大的网上加载。这样确保您的扩展程序只会执行您确实允许的代码，避免任何主动的网络攻击者，恶意地重定向您对资源的请求。
</p>

<p>
  <!--@Instead of writing code that depends on jQuery (or any other library) loading
  from an external CDN, consider including the specific version of jQuery in
  your extension package. That is, instead of:-->
  不要编写依赖于外部 CDN 加载的
  jQuery（或其他库）的代码，而应该考虑将特定版本的
  jQuery 包含在您的扩展程序包中。即，不要：
</p>

<pre data-filename="popup.html">
&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;我做的很棒的弹出内容！&lt;/title&gt;
    &lt;script src="<strong>http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js</strong>"&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;button&gt;单击看看会发生什么！&lt;/button&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>

<p>
  <!--@Download the file, include it in your package, and write:-->
  而应该下载此文件，包含在您的扩展程序包中，并编写如下代码：
<p>

<pre data-filename="popup.html">
&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;我做的很棒的弹出内容！&lt;/title&gt;
    &lt;script src="<strong>jquery.min.js</strong>"&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;button&gt;单击看看会发生什么！!&lt;/button&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>

<h2 id="relaxing"><!--@Relaxing the default policy-->放宽默认策略</h2>

<h3 id="relaxing-inline-script"><!--@Inline Script-->内嵌脚本</h3>

<p>
  <!--@There is no mechanism for relaxing the restriction against executing inline
  JavaScript. In particular, setting a script policy that includes
  <code>'unsafe-inline'</code> will have no effect.-->
  没有办法放宽限制，允许执行内嵌 JavaScript
  代码。特别地，设置包含
  <code>unsafe-inline</code>
  的脚本策略不会生效。
</p>

<h3 id="relaxing-remote-script"><!--@Remote Script-->远程脚本</h3>

<p>
  <!--@If you have a need for some external JavaScript or object
  resources, you can relax the policy to a limited extent by whitelisting
  secure origins from which scripts should be accepted. We want to ensure that
  executable resources loaded with an extension's elevated permissions are
  exactly the resources you expect, and haven't been replaced by an active
  network attacker. As <a
  href="http://en.wikipedia.org/wiki/Man-in-the-middle_attack">man-in-the-middle
  attacks</a> are both trivial and undetectable over HTTP, those origins will
  not be accepted. Currently, we allow whitelisting origins with the following
  schemes: <code>HTTPS</code>, <code>chrome-extension</code>, and
  <code>chrome-extension-resource</code>.-->
  如果您需要某些外部 JavaScript
  代码或对象资源，您可以在有限的程度上放宽策略，将安全来源的可接受脚本加入白名单。我们希望确保以扩展程序提升的权限加载的可执行资源一定是您预期的，而没有被主动的网络攻击者替换。由于<a href="http://en.wikipedia.org/wiki/Man-in-the-middle_attack">中间人攻击</a>非常普遍，并且通过
  HTTP 无法检测到，这些来源不会被接受。目前，我们允许将来源为以下协议的资源加入白名单：<code>HTTPS</code>、<code>chrome-extension</code>
  和 <code>chrome-extension-resource</code>。
</p>

<p>
  <!--@To ease development, we're also allowing the whitelisting of resources loaded
  over HTTP from servers on your local machine. You may whitelist script and
  object sources on any port of either <code>http://127.0.0.1</code> or
  <code>http://localhost</code>.-->
  为了方便开发，我们也允许将那些通过 HTTP
  从本地计算机的服务器上加载的资源列入白名单，您可以将
  <code>http://127.0.0.1</code> 或
  <code>http://localhost</code>
  任意端口上的脚本和对象来源加入白名单。
</p>

<p class="note">
  <!--@The restriction against resources loaded over HTTP applies only to those
  resources which are directly executed. You're still free, for example, to
  make XMLHTTPRequest connections to any origin you like; the default policy
  doesn't restrict <code>connect-src</code> or any of the other CSP directives
  in any way.-->
  对于通过 HTTP 加载资源的限制仅仅适用于直接执行的那些资源，您仍然可以，例如，向您希望使用的任何来源发起
  XMLHttpRequest 连接，默认策略不会以任何方式限制
  <code>connect-src</code> 或者其他任何 CSP 指示符。
</p>

<p>
  <!--@A relaxed policy definition which allows script resources to be loaded from
  <code>example.com</code> over HTTPS might look like:-->
  允许通过 HTTPS 加载来自 <code>example.com</code>
  的脚本资源的放宽策略定义如下所示：
</p>

<pre data-filename="manifest.json">
"content_security_policy": "script-src 'self' https://example.com; object-src 'self'"
</pre>

<p class="note">
  <!--@Note that both <code>script-src</code> and <code>object-src</code> are defined
  by the policy. Chrome will not accept a policy that doesn't limit each of
  these values to (at least) <code>'self'</code>.-->
  注意 <code>script-src</code> 与 <code>object-src</code>
  都由这一策略定义，Chrome
  浏览器不会接受不将这些值限制为（至少）'self'的策略。
</p>

<p>
  <!--@Making use of Google Analytics is the canonical example for this sort of
  policy definition. It's common enough that we've provided an Analytics
  boilerplate of sorts in the <a href="samples#event-tracking-with-google-analytics">Event Tracking
  with Google Analytics</a> sample extension, and a
<a href="tut_analytics">brief tutorial</a> that goes into more detail.-->
利用 Google Analytics（分析）是这一种策略定义的典型例子，这样的情况很常见，所以我们在<a href="samples#event-tracking-with-google-analytics">利用 Google Analytics（分析）追踪事件</a>的示例扩展程序中提供了简单例子，并在<a href="tut_analytics">简明教程</a>中提供了更多详情。
</p>

<h3 id="relaxing-eval"><!--@Evaluated JavaScript-->JavaScript 求值</h3>

<p>
  <!--@The policy against <code>eval()</code> and its relatives like
  <code>setTimeout(String)</code>, <code>setInterval(String)</code>, and
  <code>new Function(String)</code> can be relaxed by adding
  <code>'unsafe-eval'</code> to your policy:-->
  阻止 <code>eval</code> 及类似构造，像
  <code>setTimeout(String)</code>、<code>setInterval(String)</code>
  以及 <code>new Function(String)</code>
  的策略也可以通过向您的策略添加
  <code>unsafe-eval</code> 来放松：
</p>

<pre data-filename="manifest.json">
"content_security_policy": "script-src 'self' 'unsafe-eval'; object-src 'self'"
</pre>

<p>
  <!--@However, we strongly recommend against doing this. These functions are
  notorious XSS attack vectors.-->然而我们强烈建议您不要这么做。这些函数是臭名昭著的 XSS 攻击载体。
</p>

<h2 id="tightening"><!--@Tightening the default policy-->使用更严格的策略</h2>

<p>
  <!--@You may, of course, tighten this policy to whatever extent your extension
  allows in order to increase security at the expense of convenience. To specify
  that your extension can only load resources of <em>any</em> type (images, etc)
  from its own package, for example, a policy of <code>default-src 'self'</code>
  would be appropriate. The <a href="samples#mappy">Mappy</a> sample
  extension is a good example of an extension that's been locked down above and
  beyond the defaults.-->
  您当然也可以以带来更多不便为代价，使用您的扩展程序允许的更严格的策略，来增强安全性。例如，要指定您的扩展程序只能从自己的包中加载<em>所有</em>类型（如图片等）的资源，可以使用这样的策略：<code>default_src 'self'</code>。<a
href="samples#mappy">Mappy</a> 示例扩展程序就是使用的策略比默认设置更加严格的例子。
</p>


<h2 id="interactions"><!--@Content Scripts-->内容脚本</h2>

<p>
  <!--@The policy that we have been discussing applies to the <a
  href="background_pages">background pages</a> and <a href="event_pages">event
  pages</a> of the extension. How they apply to the <a href="content_scripts">
  content scripts</a> of the extension is more complicated.-->
  之前讨论的策略应用于扩展程序的<a href="background_pages">后台网页</a>和<a
  href="event_pages">事件页面</a>，扩展程序的<a href="content_scripts"
  >内容脚本</a>中应用这些策略时情况更复杂。
</p>

<p>
  <!--@Content scripts are generally not subject to the CSP of the extension. Since
  content scripts are not HTML, the main impact of this is that they may use
  <code>eval</code> even if the extension's CSP does not specify
  <code>unsafe-eval</code>, although this is not recommended.  Additionally, the
  CSP of the <em>page</em> does not apply to content scripts. More complicated
  are <code>&lt;script&gt;</code> tags that content scripts create and put into
  the DOM of the page they are running on. We will refer to these as DOM
  injected scripts going forward.-->
  内容脚本通常不受扩展程序 CSP 的限制。内容脚本不是
  HTML，这一点的主要影响是它们可以使用 <code>eval</code>，即使扩展程序的 CSP
  没有指定 <code>unsafe-eval</code>，尽管并不推荐这么做。此外，<em>网页</em>的
  CSP 不适用于内容脚本。更复杂的情况是内容脚本创建并加入所在网页 DOM 中的
  <code>&lt;script&gt;</code> 标签，下面我们称之为 DOM 插入脚本。
</p>

<p>
  <!--@DOM injected scripts that would be executed immediately upon injection into
  the page will execute as you might expect. Imagine a content script with the
  following code as a simple example:-->
  插入网页后立即执行的 DOM 插入脚本执行的方式与预期一致，例如考虑以下代码所示的内容脚本：
  <pre data-filename="content_script.js">
    document.write("&lt;script&gt;alert(1);&lt;/script&gt;");
  </pre>
  <!--@This content script will cause an <code>alert</code> immediately upon the
  <code>document.write()</code>. Note that this will execute regardless of the
  policy a page may specify.-->
  这段内容脚本执行 <code>document.write()</code> 时会立即显示
  <code>alert</code>，无论网页指定了什么策略它都会执行。
</p>

<p>
  <!--@However, the behavior becomes more complicated both inside that DOM injected
  script and for any script that does not immediately execute upon injection.
  Imagine that our extension is running on a page that provides its own CSP
  that specifies <code>script-src 'self'</code>. Now imagine the content script
  executes the following code:-->
  但是在 DOM 插入脚本内部以及对于插入后不会立即执行的脚本来说，情况变得更加复杂。假设我们的扩展程序在某个自己提供了
  CSP 的网页上运行，指定了 <code>script-src 'self'</code>。如果内容脚本执行以下代码：
  <pre data-filename="content_script.js">
    document.write("&lt;button onclick='alert(1);'&gt;click me&lt;/button&gt;'");
  </pre>
  <!--@If a user clicks on that button, the <code>onclick</code> script will
  <em>not</em> execute. This is because the script did not immediately execute
  and code not interpreted until the click event occurs is not considered part
  of the content script, so the CSP <em>of the page</em> (not of the extension)
  restricts its behavior. And since that CSP does not specify
  <code>unsafe-inline</code>, the inline event handler is blocked.-->
  用户单击该按钮时，<code>onclick</code>
  脚本<em>不会</em>运行，因为脚本不是立即执行的，代码要等到单击事件产生时才会解释，并不视为内容脚本的一部分，所以<em>网页的</em>
  CSP（而不是扩展程序）限制了它的行为。由于对应的 CSP 并未指定
  <code>unsafe-inline</code>，内嵌事件处理程序禁止运行。
</p>

<p>
  <!--@The correct way to implement the desired behavior in this case would be to add
  the <code>onclick</code> handler as a function from the content script as
  follows:-->
  在这种情况下，实现期望行为的正确方式是在内容脚本中将函数添加为
  <code>onclick</code> 处理程序，如下所示：
  <pre data-filename="content_script.js">
    document.write("&lt;button id='mybutton'&gt;click me&lt;/button&gt;'");
    var button = document.getElementById('mybutton');
    button.onclick = function() {
      alert(1);
    };
  </pre>
</p>

<p>
  <!--@Another similar issue arises if the content script executes the following:-->
  如果内容脚本执行以下代码的话就会产生另一种类似的问题：
  <pre data-filename="content_script.js">
    var script = document.createElement('script');
    script.innerHTML = 'alert(1);'
    document.getElementById('body').appendChild(script);
  </pre>
  <!--@In this case, the script <em>will</em> execute and the alert will pop up.
  However, take this case:-->
  这种情况下，脚本<em>会</em>执行，并弹出对话框。但是，考虑如下情况：
  <pre data-filename="content_script.js">
    var script = document.createElement('script');
    script.innerHTML = 'eval("alert(1);")';
    document.getElementById('body').appendChild(script);
  </pre>
  <!--@While the initial script will execute, the call to <code>eval</code> will be
  blocked. That is, while the initial script execution is allowed, the behavior
  within the script will be regulated by the page's CSP.-->
  尽管一开始脚本会运行，<code>eval</code> 的调用则会被阻止，因为尽管一开始的脚本执行是允许的，脚本内的行为受到网页
  CSP 的约束。
</p>

<p>
  <!--@Thus, depending on how you write DOM injected scripts in your extension,
  changes to the page's CSP may affect the behavior of your extension. Since
  content scripts are <em>not</em> affected by the page's CSP, this a great
  reason to put as much behavior as possible of your extension into the content
  script rather than DOM injected scripts.-->
  所以，取决于您在扩展程序中编写 DOM 插入脚本的方式，网页 CSP
  的更改可能会影响扩展程序的行为。由于内容脚本<em>不受</em>网页 CSP 影响，您应该尽量将扩展程序的大部分行为放在内容脚本中，而不是
  DOM 插入脚本中。
</p>
