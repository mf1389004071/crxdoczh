// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// <!--@Use the <code>chrome.mediaGalleries</code> API to access media files (audio,
// images, video) from the user's local disks (with the user's consent).-->
// 使用 <code>chrome.mediaGalleries</code> API
// 从用户的本地磁盘（包含用户内容）中访问媒体文件（音频、图片、视频）。
namespace mediaGalleries {

  [inline_doc] enum GetMediaFileSystemsInteractivity {
    // <!--@Do not act interactively.-->
    // 不要交互式地进行。
    no,
    // <!--@Ask the user to manage permitted media galleries.-->
    // 询问用户管理允许的媒体库。
    yes,
    // <!--@Ask the user to manage permitted galleries only if the return set would
    // otherwise be empty.-->
    // 只有当返回值会为空时才询问用户管理允许的媒体库。
    if_needed
  };

  [inline_doc] enum GetMetadataType {
    // <!--@Retrieve all available metadata.-->
    // 获取所有可用的元数据。
    all,
    // <!--@Retrieve only the mime type.-->
    // 仅获取 MIME 类型。
    mimeTypeOnly
  };

  [inline_doc] enum ScanProgressType {
    // <!--@The scan started.-->
    // 扫描开始。
    start,
    // <!--@The scan was cancelled.-->
    // 扫描取消。
    cancel,
    // <!--@The scan finished but none of the result have been added,
    // addScanResults() has to be called to ask the user for permission.-->
    // 扫描完成，但是结果还没添加，您必须调用 addScanResults()
    // 得到用户的许可。
    finish,
    // <!--@The scan encountered an error and could not proceed.-->
    // 扫描遇到错误，不能继续进行。
    error
  };

  [inline_doc] dictionary MediaFileSystemsDetails {
    // <!--@Whether to prompt the user for permission to additional media galleries
    // before returning the permitted set. Default is silent.  If the value
    // 'yes' is passed, or if the application has not been granted access to
    // any media galleries and the value 'if_needed' is passed, then the
    // media gallery configuration dialog will be displayed.-->
    // 返回允许的内容前是否提示用户访问其他媒体库的权限，默认情况下不提示。如果传递了
    // 'yes'，或者如果应用没有被授予访问任何媒体库的权限并且传递了
    // 'if_needed'，则会显示媒体库配置对话框。
    GetMediaFileSystemsInteractivity? interactive;
  };

  [inline_doc] dictionary MediaMetadataOptions {
    // <!--@Specifies which subset of the metadata to retrieve. Defaults to 'all'
    // if the option is omitted.-->
    // 指定要获取哪些元数据，如果省略该选项则默认为 'all'（全部）。
    GetMetadataType? metadataType;
  };

  callback MediaFileSystemsCallback =
      void ([instanceOf=DOMFileSystem] optional object[] mediaFileSystems);

  callback AddUserFolderCallback =
      void ([instanceOf=DOMFileSystem] object[] mediaFileSystems,
            DOMString selectedFileSystemName);

  [inline_doc] dictionary MediaFileSystemMetadata {
    // <!--@The name of the file system.-->
    // 文件系统的名称。
    DOMString name;

    // <!--@A unique and persistent id for the media gallery.-->
    // 媒体库的唯一持久标识符。
    DOMString galleryId;

    // <!--@If the media gallery is on a removable device, a unique id for the
    // device while the device is online.-->
    // 如果媒体库位于可移动设备上，并且设备在线，则为设备的唯一标识符。
    DOMString? deviceId;

    // <!--@True if the media gallery is on a removable device.-->
    // 如果媒体库在可移动设备上则为 true。
    boolean isRemovable;

    // <!--@True if the device the media gallery is on was detected as a media
    // device.  i.e. a PTP or MTP device, or a DCIM directory is present.-->
    // 如果检测到媒体库所在的设备是媒体设备（即 PTP 或 MTP
    // 设备，或存在 DCIM 目录）则为 true。
    boolean isMediaDevice;

    // <!--@True if the device is currently available.-->
    // 如果设备当前可用则为 true。
    boolean isAvailable;
  };

  [inline_doc] dictionary ScanProgressDetails {
    // <!--@The type of progress event, i.e. start, finish, etc.-->
    // 进度事件的类型，例如 start（开始）、finish（完成）等。
    ScanProgressType type;

    // <!--@The number of Galleries found.-->
    // 找到的媒体库数目。
    long? galleryCount;

    // <!--@Appoximate number of media files found; some file types can be either
    // audio or video and are included in both counts.-->
    // 找到的媒体文件的大致数目。某些文件类型既有可能是音频，也有可能是视频，在这两种类型中都会计算在内。
    long? audioCount;
    long? imageCount;
    long? videoCount;
  };

  callback MediaFileSystemsMetadataCallback =
      void (MediaFileSystemMetadata[] metadata);

  dictionary MediaMetadata {
    // <!--@The browser sniffed mime type.-->
    // 浏览器检测到的 MIME 类型。
    DOMString mimeType;

    // <!--@Defined for images and video. In pixels.-->
    // 图片和视频会包含这些属性，以像素为单位。
    long? height;
    long? width;

    // <!--@Defined for audio and video. In seconds.-->
    // 音频和视频会包含该属性，以秒为单位。
    double? duration;

    // <!--@Generic metadata tags.-->
    // 通用元数据标签。
    DOMString? album;
    DOMString? artist;
    DOMString? comment;
    DOMString? copyright;
    long? disc;
    DOMString? genre;
    DOMString? language;
    DOMString? title;
    long? track;
  };

  callback MediaMetadataCallback = void (MediaMetadata metadata);

  interface Functions {
    // <!--@Get the media galleries configured in this user agent. If none are
    // configured or available, the callback will receive an empty array.-->
    // 获取当前用户代理配置下的媒体库。如果没有配置或者没有可用的媒体库，回调函数将会接收空数组。
    static void getMediaFileSystems(optional MediaFileSystemsDetails details,
                                    MediaFileSystemsCallback callback);

    // <!--@Present a directory picker to the user and add the selected directory
    // as a gallery. If the user cancels the picker, selectedFileSystemName
    // will be empty.
    // A user gesture is required for the dialog to display. Without a user
    // gesture, the callback will run as though the user canceled.-->
    // 向用户显示选择文件夹对话框，并将选定目录添加为媒体库。如果用户取消对话框，selectedFileSystemName
    // 为空。需要用户操作才能显示对话框，如果没有用户操作，调用回调函数时就像用户取消操作一样。
    static void addUserSelectedFolder(AddUserFolderCallback callback);

    // <!--@Start a scan of the user's hard disks for directories containing media.
    // The scan may take a long time so progress and completion is communicated
    // by events. No permission is granted as a result of the scan, see
    // addScanResults.-->
    // 开始扫描用户的硬盘，寻找包含媒体的目录。扫描可能需要很长时间，所以进度和完成情况通过事件的方式通知。扫描完成后不会授予任何权限，而需要调用
    // addScanResults。
    static void startMediaScan();

    // <!--@Cancel any pending media scan.  Well behaved apps should provide a way
    // for the user to cancel scans they start.-->
    // 取消正在进行的媒体扫描，正常情况下应用应该提供某种方式让用户取消他们开始的扫描操作。
    static void cancelMediaScan();

    // <!--@Show the user the scan results and let them add any or all of them as
    // galleries. This should be used after the 'finish' onScanProgress()
    // event has happened. A galleries the app has access to are returned, not
    // just the newly added galleries.-->
    // 向用户显示扫描的结果，并让他们将其中的一部分或者全部添加为媒体库。该方法应该在
    // 'finish'（完成）类型的  onScanProgress
    // 事件产生之后调用，调用后返回应用能够访问的所有媒体库，而不仅仅是新增加的媒体库。
    static void addScanResults(MediaFileSystemsCallback callback);

    // <!--@Get metadata about a specific media file system.-->
    // 获取指定媒体文件系统的元数据。
    [nocompile] static MediaFileSystemMetadata getMediaFileSystemMetadata(
        [instanceOf=DOMFileSystem] object mediaFileSystem);

    // <!--@Get metadata for all available media galleries.-->
    // 获取所有可用媒体库的元数据。
    static void getAllMediaFileSystemMetadata(
        MediaFileSystemsMetadataCallback callback);

    // <!--@Gets the media-specific metadata for a media file. This should work
    // for files in media galleries as well as other DOM filesystems.-->
    // 获取媒体文件特定的元数据，媒体库和其他 DOM
    // 文件系统中的文件都可以使用该方法。
    static void getMetadata([instanceOf=Blob] object mediaFile,
                            optional MediaMetadataOptions options,
                            MediaMetadataCallback callback);
  };

  interface Events {
    // <!--@The pending media scan has changed state. See details for more
    // information.-->
    // 正在进行中的媒体扫描已经更改状态，有关更多信息请参见 details 参数。
    static void onScanProgress(ScanProgressDetails details);
  };
};
