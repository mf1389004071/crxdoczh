<h1>Webview <!--@Tag-->标签 API</h1>

<table class="intro">
  <tr>
    <th scope="col"></th>
    <th scope="col"></th>
  </tr>
  <tr>
    <td><strong><!--@Description:-->描述：</strong></td>
    <td><!--@Use the <code>webview</code> tag to actively load live content
    from the web over the network and embed it in your packaged app.
    Your app can control the appearance of the <code>webview</code> and
    interact with the web content,
    initiate navigations in an embedded web page,
    react to error events that happen within it, and more
    (see <a href="#usage">Usage</a>).-->
    使用 <code>webview</code>
    标签主动通过网络加载网上的活动内容，并将它嵌入在您的打包应用中。您的应用可以控制
    <code>webview</code>
    的外观，与网上内容交互，在嵌入的网页中进行导航，响应其中发生的错误事件等等。（请参见<a href="#usage">用法</a>）。
    </td>
  </tr>
  <tr>
    <td><strong><!--@Availability:-->可用版本：</strong></td>
    <td><!--@Available in Chrome 25 or later-->在 Chrome 25 或更高版本中可用</td>
  </tr>
  <tr>
    <td><strong><!--@Permissions:-->权限：</strong></td>
    <td><code>"webview"</code></td>
  </tr>
  <tr>
    <td><strong><!--@Samples:-->示例：</strong></td>
    <td><a href="https://github.com/GoogleChrome/chrome-app-samples/tree/master/browser">browser</a><!--@;--><br>
    <a href="https://github.com/GoogleChrome/chrome-app-samples/tree/master/tcpserver">tcpserver</a><!--@;--><br>
    <a href="https://github.com/GoogleChrome/chrome-app-samples/tree/master/webview">webview</a>
    </td>
  </tr>
  <tr>
    <td><strong><!--@Learn more:-->了解更多：</strong></td>
    <td><a href="app_external.html"><!--@Embed Content-->嵌入内容</a><!--@;--><br>
    <a href="https://developers.google.com/live/shows/7320022-11001/">Chrome <!--@Apps Office Hours - the WebView Control-->应用办公时间——WebView 控件</a></td>
  </tr>
</table>

<h2 id="usage"><!--@Usage-->用法</h2>

<p>
<!--@Use the <code>webview</code> tag to embed 'guest' content
(such as web pages) in your packaged app.
The guest content is contained within the <code>webview</code> container;
an embedder page within your packaged app controls
how the guest content is laid out and rendered.-->
使用 <code>webview</code>
标签在您的打包应用中嵌入“来宾”内容（例如网页）。来宾内容包含在
<code>webview</code>
容器中，您的打包应用中的嵌入者网页控制来宾内容的布局和渲染方式。
</p>

<p>
<!--@Different from the <code>iframe</code>,
the <code>webview</code>
runs in a separate process than your app;
it doesn't have the same permissions as your app and
all interactions between your app and embedded content will be asynchronous.
This keeps your app safe from the embedded content.-->
与 <code>iframe</code> 不同，<code>webview</code>
在一个单独的进程中运行，而不是在您的应用中。它并不拥有您的应用具有的权限，而且您的应用和嵌入内容之间的交互都是异步的，这样可以确保您的应用的安全，不受嵌入内容的影响。
</p>

<h2 id="example"><!--@Example-->例子</h2>

<p>
<!--@To embed a web page in your app,
add the <code>webview</code> tag to your app's embedder page
(this is the app page that will display the guest content).
In its simplest form,
the <code>webview</code> tag includes the <code>src</code> of the web page
and css styles that control the appearance of the <code>webview</code> container:-->
要想在您的应用中嵌入网页，请在您的应用的嵌入者页面（即显示来宾内容的应用页面）中添加
<code>webview</code> 标签。<code>webview</code> 标签最简单的形式包括网页的
<code>src</code>（来源）以及控制 <code>webview</code> 容器外观的 CSS 样式：
</p>

<pre>&lt;webview id="foo" src="http://www.google.com/" style="width:640px; height:480px"&gt;&lt;/webview&gt;</pre>

<p class="note">
<b><!--@Note:-->注意：</b><!--@
You can only use css styles
to control the look and feel of the container,
for example, the container size.
You cannot use css to control the guest content itself.-->您只能使用 CSS
样式控制容器的外观与风格，例如容器大小，而不能控制来宾内容本身。
</p>

<p>
<!--@If you want to control the guest content in any way,
you can write JavaScript that listens for <a href="#events">webview events</a>
and responds to those events using the <a href="#methods">webview methods</a>.
Here's sample code in <code>app.js</code>
with two event listeners:
one that listens for the web page to start loading,
the other for the web page to stop loading,
and displays a "loading..." message during the load time:-->
如果您希望以任何方式控制来宾内容，您可以编写 JavaScript，监听
<a href="#events">webview 事件</a>，并使用
<a href="#methods">webview 方法</a>响应这些事件。如下是 <code>app.js</code>
中的示例代码，包含两个事件监听器：一个监听网页开始加载，另一个监听网页停止加载，并在加载的时候显示“正在加载...”消息：
</p>

<pre>
onload = function() {
  var webview = document.getElementById("foo");
  var indicator = document.querySelector(".indicator");

  var loadstart = function() {
    indicator.innerText = "正在加载...";
  }
  var loadstop = function() {
    indicator.innerText = "";
  }
  webview.addEventListener("loadstart", loadstart);
  webview.addEvevntListener("loadstop", loadstop);
}
</pre>

<h2 id="tag"><!--@Tag attributes-->标签属性</h2>

<h3 id="src">src</h3>
  <div class="summary">
    <pre>&lt;webview id="foo" <strong>src="http://www.google.com/"</strong> style="width:640px; height:480px"&gt;&lt;/webview&gt;</pre>
  </div>
  <div class="description">
    <p>
    <!--@Returns the visible URL.
    Mirrors the logic in the browser's omnibox:
    either returning a pending new navigation if initiated by the embedder page,
    or the last committed navigation.
    Writing to this attribute initiates top-level navigation.-->
    返回可见的 URL，与浏览器多功能框的逻辑类似：如果嵌入者网页产生新的待定的导航则返回它，否则返回最后提交的导航。写入该属性将产生顶层导航。
    </p>
  </div>

<h3 id="partition">partition</h3>
  <div class="summary">
    <pre>&lt;webview id="foo" src="http://www.google.com/" style="width:640px; height:480px" <strong>partition="persist:googlepluswidgets"</strong>&gt;&lt;/webview&gt;</pre>
  </div>
  <div class="description">
    <p>
    <!--@Storage partition ID used by the <code>webview</code> tag.
    If the storage partition ID starts with <code>persist:</code>
    (<code>partition="persist:googlepluswidgets"</code>),
    the <code>webview</code> will use a persistent storage partition
    available to all guests in the app
    with the same storage partition ID.
    If the ID is unset or if there is no <code>'persist':</code> prefix,
    the <code>webview</code> will use an in-memory storage partition.
    This value can only be modified before the first navigation,
    since the storage partition of an active renderer process cannot change.
    Subsequent attempts to modify the value will fail with a DOM exception.
    By assigning the same partition ID,
    multiple webviews can share the same storage partition.-->
    <code>webview</code> 标签使用的存储分区标识符。如果存储分区标识符以
    <code>persist:</code>
    开始（<code>partition="persist:googlepluswidgets"</code>），<code>webview</code>
    将使用持久存储分区，对于应用中具有相同存储分区标识符的所有来宾都可用。如果没有设置标识符或者没有
    <code>persist:</code> 前缀，<code>webview</code>
    将使用内存中的存储分区。只有在第一次导航开始前才能修改该属性值，因为活动渲染器进程的存储分区不能更改。如果之后尝试修改这一值将会失败，并产生
    DOM 异常。指定同一个分区标识符，多个 webview 可以共享同一个存储分区。
    </p>
    <p class="note">
    <strong><!--@Exception thrown:-->可能产生的异常：</strong>
    <!--@The partition attribute must be valid for navigation to proceed.
    In the case of an invalid partition, such as <code>partition="persist:"</code>,
    the <a href="#src">src attribute</a> cannot be set and an exception is thrown.-->
    分区属性必须合法，导航才能继续。如果指定了无效的分区，例如
    <code>partition="persist:"</code>，您将无法设置
    <a href="#src">src 属性</a>，并会产生异常。
    </p>
  </div>

<h3 id="autosize">autosize</h3>
  <div class="summary">
    <pre>&lt;webview id="foo" src="http://www.google.com/" style="width:640px; height:480px" <strong>autosize="on" minwidth="576" minheight="432"</strong>&gt;&lt;/webview&gt;</pre>
  </div>
  <div class="description">
    <p>
    <!--@If "on", the <code>webview</code> will fire the <a href="#event-sizechanged">sizechanged</a> event
    and adjust the size of the guest content within the <code>webview</code> container,
    provided you have written event handlers to change these dimensions.
    You can also include size contraints on the guest content:
    <code>minwidth</code>, <code>minheight</code>,
    <code>maxwidth</code>, <code>maxheight</code>.
    These contraints do not impact the <code>webview</code> UNLESS <code>autosize</code> is enabled.
    When autosize is enabled, the <code>webview</code> content cannot be less than the minimum values
    or greater than the maximum.-->
    如果为 "on"，<code>webview</code> 会产生
    <a href="#event-sizechanged">sizechanged</a> 事件，并调整
    <code>webview</code> 容器内来宾内容的大小，但是您首先需要编写事件处理程序来更改这些维度。您也可以对来宾内容的大小进行约束：<code>minwidth</code>、<code>minheight</code>、<code>maxwidth</code>、<code>maxheight</code>。<em>除非</em>启用了
    <code>autosize</code>，否则这些约束不会影响
    <code>webview</code>。启用自动调整大小后，<code>webview</code>
    的内容不能小于最小值或大于最大值。
    </p>
  </div>

<h2 id="methods"><!--@Methods-->方法</h2>

<h3 id="stop">stop</h3>
  <div class="summary">
    <pre>stop()</pre>
  </div>
  <div class="description">
    <p>
    <!--@Stops the loading of the current <code>webview</code> navigation, if one is in progress.-->
    如果正在进行，则停止加载当前的 <code>webview</code> 导航。
    </p>
  </div>

<h3 id="reload">reload</h3>
  <div class="summary">
    <pre>reload()</pre>
  </div>
  <div class="description">
    <p>
    <!--@Reloads the current top-level page.-->
    重新加载当前的顶层网页。
    </p>
  </div>

<h3 id="back">back / forward / go</h3>
  <div class="summary">
    <pre>back()<br>forward()<br>go(integer <i>relativeIndex</i>)</pre>
  </div>
  <div class="description">
    <p>
    <!--@Initiates a history navigation back, forward, or to a relative index, if possible.
    Includes history navigations to subframes.
    The <code>go()</code> method has a <code>relativeIndex</code> parameter,
    which can either be a positive integer, meaning to go forward a certain number of entries,
    or negative, meaning to go back.-->
    根据历史记录进行后退、前进或相对索引（如果可能的话）导航，包括子框架导航的历史记录。<code>go</code>
    方法有一个 <code>relativeIndex</code> 参数，可以为正整数，表示前进一定数目的条目，也可以为负整数，表示后退。
    </p>
  </div>

<h3 id="canGoBack">canGoBack / canGoForward</h3>
  <div class="summary">
    <pre>canGoBack()<br>canGoForward()</pre>
  </div>
  <div class="description">
    <p>
    <!--@Indicates whether it is possible to go back or forward from the current state.-->
    表示当前状态下是否可以后退或前进。
    </p>
  </div>

<h3 id="postMessage">contentWindow.postMessage</h3>
  <div class="summary">
    <pre>contentWindow.postMessage(message, targetOrigin)</pre>
  </div>
  <div class="description">
    <p>
    <!--@Posts <code>message</code> (example: "Message from app to embedded page")
    to the embedded web content,
    as long as the embedded content is displaying a page
    from the <code>targetOrigin</code> (example: "https://www.google.com").
    This method isn't available until the page has completed loading.
    Listen to the <a href="#event-loadstop">loadstop event</a>
    and then call the method.
    Allows the guest to send replies and
    provides the guest web page with a JavaScript reference
    to the embedder page's window (via <code>event.source</code>).
    Uses the same
    <a href="https://developer.mozilla.org/en-US/docs/DOM/window.postMessage">HTML5 postMessage</a>
    API as between web pages.
    The embedder should listen for replies
    by adding a <code>message</code> event listener to its own frame.
    The <code>event.source</code> corresponds to the guest frame that sent the reply.-->
    如果嵌入内容显示的网页来自 <code>targetOrigin</code>
    指定的来源（例如："https://www.google.com"），则会向嵌入的网上内容发送消息（<code>message</code>，例如："从应用到嵌入网页的消息"）。只有在页面加载完成后该方法才可用，请监听
    <a href="#event-loadstop">loadstop 事件</a>并调用该方法。该方法允许来宾发送回复，并会向来宾提供嵌入者网页窗口的
    JavaScript 引用（通过 <code>event.source</code>），使用的是和网页相同的
    <a href="https://developer.mozilla.org/en-US/docs/DOM/window.postMessage">HTML5 postMessage</a> API。嵌入者应该在自己的框架中添加
    <code>message</code> 事件监听器，以便监听回复，<code>event.source</code>
    对应于发送回复的来宾框架。
    </p>
  </div>

<h3 id="getProcessID">getProcessId</h3>
  <div class="summary">
    <pre>getProcessId()</pre>
  </div>
  <div class="description">
    <p>
    <!--@Returns Chrome's internal process ID
    for the guest web page's current process,
    allowing embedders to know how many guests would be affected
    by terminating the process.
    Two guests will share a process only if
    they belong to the same app and have the same
    <a href="#partition">storage partition ID</a>.
    The call is synchronous and returns the embedder's cached notion
    of the current process ID.
    The process ID isn't the same as the operating system's process ID.-->
    返回来宾网页当前进程对应的 Chrome 浏览器的内部进程标识符，允许嵌入者了解如果终止该进程会影响多少来宾。只有当两个来宾属于同一个应用并且拥有相同的<a
    href="#partition">存储分区标识符</a>时才会共享一个进程。该调用是同步的，返回嵌入者缓存的当前进程标识符，这一进程标识符与操作系统的进程标识符不同。
    </p>
  </div>

<h3 id="terminate">terminate</h3>
  <div>
    <pre>terminate()</pre>
  </div>
  <div class="description">
    <p>
    <!--@Forcibly kills the guest web page's renderer process.
    This may affect multiple <code>webview</code> tags in the current app
    if they share the same process,
    but it will not affect <code>webview</code> tags in other apps.-->
    强制终止来宾网页的渲染器进程，如果共享同一个进程的话，这样可能会影响当前应用中的多个
    <code>webview</code> 标签，但不会影响其他应用中的 <code>webview</code>
    标签。
    </p>
  </div>

<h2 id="events"><!--@Events-->事件</h2>
  
  <p>
  <!--@Each event handler is a function that takes in an event object.
  Each event object has a <code>name</code> property matching the event's name,
  so that one event handler function can be used to handle multiple types of events.
  Event handlers are specified using
  <code>addEventListener("eventName", function)</code>.-->
  每一个事件处理程序都是一个接受事件对象的函数，每一个事件对象包含
  <code>name</code>
  属性，与事件名称匹配，这样一个事件处理函数可以用来处理多种类型的事件。事件处理程序使用
  <code>addEventListener("eventName", function)</code>
  指定。
  </p>

<h3 id="event-loadstart">loadstart</h3>
  <div class="summary">
    <pre>addEventListener("loadstart", function(string <i>url</i>, boolean <i>isTopLevel</i>))</pre>
  </div>
  <div class="description">
    <p>
    <!--@Fired when a load has begun.-->
    开始加载时产生。
    </p>    
    <h4><!--@Properties-->属性</h4>
      <dt>
        <span class="property">url</span>
      </dt>
      <dd>
        <!--@Requested URL.-->
        请求的 URL。
      </dd>
      <dt>
        <span class="property">isTopLevel</span>
      </dt>
      <dd>
        <!--@Whether the load is top-level or in a subframe.-->
        本次加载来自顶层还是子框架。
      </dd>
  </div>

<h3 id="event-loadabort">loadabort</h3>
  <div class="summary">
    <pre>addEventListener("loadabort", function(string <i>url</i>, boolean <i>isTopLevel</i>, string <i>reason</i>))</pre>
  </div>
  <div class="description">
    <p>
    <!--@Fired when a top-level load has aborted without committing.-->
    当顶层的加载提交前就终止时产生。
    </p>
    <h4><!--@Properties-->属性</h4>
      <dt>
       	<span class="property">url</span>
      </dt>
      <dd>
        <!--@Requested URL.-->
        请求的 URL。
      </dd>
      <dt>
        <span class="property">isTopLevel</span>
      </dt>
      <dd>
        <!--@Whether the load is top-level or in a subframe.-->
        本次加载来自顶层还是子框架。
      </dd>
      <dt>
       	<span class="property">reason</span>
      </dt>
      <dd>
        <!--@String indicating what type of abort occurred:
        <code>networkError</code>, <code>download</code>,
       	<code>canceled</code>, <code>sslError</code>, <code>safeBrowsingError</code>.-->
        表示发生的终止类型的字符串：<code>networkError</code>（网络错误）、<code>download</code>（下载）、<code>canceled</code>（已取消）、<code>sslError</code>（SSL 错误）、<code>safeBrowsingError</code>（安全浏览错误）。
      </dd>
  </div>

<h3 id="event-loadredirect">loadredirect</h3>
  <div class="summary">
    <pre>addEventListener("loadredirect", function(string <i>oldUrl</i>, string <i>newUrl</i>, boolean <i>isTopLevel</i>))</pre>
  </div>
  <div class="description">
      <p>
      <!--@Fired when a top-level load request has redirected to a different URL.-->
      当顶层加载请求重定向至另一个不同的 URL 时产生。
      </p>
      <h4><!--@Properties-->属性</h4>
        <dt>
       	  <span class="property">oldUrl</span>
        </dt>
        <dd>
       	  <!--@The requested URL, before the redirect.-->
          重定向之前的请求 URL。
        </dd>
        <dt>
       	  <span class="property">newUrl</span>
        </dt>
        <dd>
       	  <!--@The new requested URL.-->
          新的请求 URL。
        </dd>
        <dt>
       	  <span class="property">isTopLevel</span>
        </dt>
        <dd>
       	  <!--@Whether the redirect happened at top-level or in a subframe.-->
          重定向发生在顶层还是子框架。
        </dd>
  </div>
  <div>

<h3 id="event-loadcommit">loadcommit</h3>
  <div class="summary">
    <pre>addEventListener("loadcommit", function(string <i>url</i>, boolean <i>isTopLevel</i>))</pre>
  </div>
  <div class="description">
    <p>
    <!--@Fired when a load has committed.-->
    一次加载提交时产生。
    </p>
    <h4><!--@Properties-->属性</h4>
      <dt>
        <span class="property">url</span>
      </dt>
      <dd>
        <!--@The URL that committed.-->
        已提交的 URL。
      </dd>
      <dt>
        <span class="property">isTopLevel</span>
      </dt>
      <dd>
        <!--@Whether the load is top-level or in a subframe.-->
        本次加载来自顶层还是子框架。
      </dd>
  </div>

<h3 id="event-loadstop">loadstop</h3>
  <div class="summary">
    <pre>addEventListener("loadstop", function)</pre>
  </div>
  <div class="description">
    <p>
    <!--@Fired when all loads in the tag (including all subframes) have completed.
    Fires in addition to any <a href="#event-loadcommit">loadCommit</a>
    or <a href="#event-loadabort">loadAbort</a> events,
    which occur per-frame.-->
    除了每一个框架都会发生的
    <a href="#event-loadcommit">loadCommit</a> 或
    <a href="#event-loadabort">loadAbort</a>
    外，当标签中的所有加载（包括所有子框架）完成后也会产生该事件。
    </p>
  </div>

<h3 id="event-sizechanged">sizechanged</h3>
  <div class="summary">
    <pre>addEventListener("sizechanged", function(integer <i>oldWidth</i>, integer <i>oldHeight</i>, integer <i>newWidth</i>, integer <i>newHeight</i>))</pre>
  </div>
  <div class="description">
    <p>
    <!--@Fired when the embedded web content has been resized.
    Only fires if <a href="#autosize">autosize</a> enabled.-->
    当嵌入的网上内容更改大小时产生，只有在启用
    <a href="#autosize">autosize</a> 时才会产生。
    </p>
    <h4><!--@Properties-->属性</h4>
      <dt>
        <span class="property">oldWidth</span>
      </dt>
      <dd>
        <!--@Old width of embedded web content.-->
        嵌入的网上内容原来的宽度。
      </dd>
      <dt>
        <span class="property">oldHeight</span>
      </dt>
      <dd>
        <!--@Old height of embedded web content.-->
        嵌入的网上内容原来的高度。
      </dd>
      <dt>
        <span class="property">newWidth</span>
      </dt>
      <dd>
        <!--@New width of embedded web content.-->
        嵌入的网上内容现在的宽度。
      </dd>
      <dt>
        <span class="property">newHeight</span>
      </dt>
      <dd>
        <!--@New height of embedded web content.-->
        嵌入的网上内容现在的高度。
      </dd>
  </div>

<h3 id="event-exit">exit</h3>
  <div class="summary">
    <pre>addEventListener("exit", function(integer <i>processID</i>, string <i>reason</i>))</pre>
  </div>
  <div class="description">
    <p>
    <!--@Fired when the process rendering the guest web content has exited.-->
    当渲染来宾网上内容的进程退出时产生。
    </p>
    <h4><!--@Properties-->属性</h4>
      <dt>
        <span class="property">processID</span>
      </dt>
      <dd>
        <!--@Chrome's internal ID of the process that exited.-->
        退出的进程对应的 Chrome 浏览器内部标识符。
      </dd>
      <dt>
        <span class="property">reason</span>
      </dt>
      <dd>
        <!--@String indicating a reason for the exit:
       	<code>normal</code>, <code>abnormal</code>,
       	<code>crash</code>, <code>kill</code>.-->
        表示退出原因的字符串：<code>normal</code>（正常）、<code>abnormal</code>（异常）、<code>crash</code>（崩溃）、<code>kill</code>（被终止）。
      </dd>
  </div>

<h3 id="event-unresponsive">unresponsive</h3>
  <div class="summary">
    <pre>addEventListener("unresponsive", function(integer <i>processID</i>))</pre>
  </div>
  <div class="description">
    <p>
    <!--@Fired when the process rendering the guest web content has become unresponsive.
    This event will be generated once,
    with a matching <a href="#event-responsive">responsive</a> event
    if the guest begins to respond again.-->
    当渲染来宾网上内容的进程停止响应时产生。该事件产生一次后，如果来宾再次响应，会产生与之匹配的
    <a href="#event-responsive">responsive</a>事件。
    </p>
    <h4><!--@Properties-->属性</h4>
      <dt>
        <span class="property">processID</span>
      </dt>
      <dd>
        <!--@Chrome's internal ID of the process that hung.-->
        停止响应的进程对应的 Chrome 浏览器内部标识符。
      </dd>
  </div>
    
<h3 id="event-responsive">responsive</h3>
  <div class="summary">
    <pre>addEventListener("responsive", function(integer <i>processID</i>))</pre>
  </div>
  <div class="description">
    <p>
    <!--@Fired when the process rendering the guest web content has become responsive again
    after being unresponsive.-->
    当渲染来宾网上内容的进程由未响应恢复到响应状态时产生。
    </p>
    <h4><!--@Properties-->属性</h4>
      <dt>
        <span class="property">processID</span>
      </dt>
      <dd>
        <!--@Chrome's internal ID of the process that became responsive.-->
        恢复响应的进程对应的 Chrome 浏览器内部标识符。
      </dd>
  </div>

